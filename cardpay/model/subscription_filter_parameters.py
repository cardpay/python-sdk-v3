# coding: utf-8

"""
    CardPay REST API

    Welcome to the CardPay REST API. The CardPay API uses HTTP verbs and a [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) resources endpoint structure (see more info about REST). Request and response payloads are formatted as JSON. Merchant uses API to create payments, refunds, payouts or recurrings, check or update transaction status and get information about created transactions. In API authentication process based on [OAuth 2.0](https://oauth.net/2/) standard. For recent changes see changelog section.  # noqa: E501

    OpenAPI spec version: 3.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class SubscriptionFilterParameters(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        "request_id": "str",
        "max_count": "int",
        "offset": "int",
        "sort_order": "str",
        "customer_id": "str",
        "plan_id": "str",
        "start_time": "datetime",
        "end_time": "datetime",
        "currency": "str",
        "status": "str",
        "type": "str",
    }

    attribute_map = {
        "request_id": "request_id",
        "max_count": "max_count",
        "offset": "offset",
        "sort_order": "sort_order",
        "customer_id": "customer_id",
        "plan_id": "plan_id",
        "start_time": "start_time",
        "end_time": "end_time",
        "currency": "currency",
        "status": "status",
        "type": "type",
    }

    def __init__(
        self,
        request_id=None,
        max_count=None,
        offset=None,
        sort_order=None,
        customer_id=None,
        plan_id=None,
        start_time=None,
        end_time=None,
        currency=None,
        status=None,
        type=None,
    ):  # noqa: E501
        """SubscriptionFilterParameters - a model defined in Swagger"""  # noqa: E501

        self._request_id = None
        self._max_count = None
        self._offset = None
        self._sort_order = None
        self._customer_id = None
        self._plan_id = None
        self._start_time = None
        self._end_time = None
        self._currency = None
        self._status = None
        self._type = None
        self.discriminator = None

        self.request_id = request_id
        if max_count is not None:
            self.max_count = max_count
        if offset is not None:
            self.offset = offset
        if sort_order is not None:
            self.sort_order = sort_order
        if customer_id is not None:
            self.customer_id = customer_id
        if plan_id is not None:
            self.plan_id = plan_id
        if start_time is not None:
            self.start_time = start_time
        if end_time is not None:
            self.end_time = end_time
        if currency is not None:
            self.currency = currency
        if status is not None:
            self.status = status
        if type is not None:
            self.type = type

    @property
    def request_id(self):
        """Gets the request_id of this SubscriptionFilterParameters.  # noqa: E501

        Request ID  # noqa: E501

        :return: The request_id of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: str
        """
        return self._request_id

    @request_id.setter
    def request_id(self, request_id):
        """Sets the request_id of this SubscriptionFilterParameters.

        Request ID  # noqa: E501

        :param request_id: The request_id of this SubscriptionFilterParameters.  # noqa: E501
        :type: str
        """
        if request_id is None:
            raise ValueError(
                "Invalid value for `request_id`, must not be `None`"
            )  # noqa: E501
        if request_id is not None and len(request_id) > 50:
            raise ValueError(
                "Invalid value for `request_id`, length must be less than or equal to `50`"
            )  # noqa: E501
        if request_id is not None and len(request_id) < 1:
            raise ValueError(
                "Invalid value for `request_id`, length must be greater than or equal to `1`"
            )  # noqa: E501

        self._request_id = request_id

    @property
    def max_count(self):
        """Gets the max_count of this SubscriptionFilterParameters.  # noqa: E501

        Limit number of returned subscriptions (must be less than 10000, default is 1000)  # noqa: E501

        :return: The max_count of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: int
        """
        return self._max_count

    @max_count.setter
    def max_count(self, max_count):
        """Sets the max_count of this SubscriptionFilterParameters.

        Limit number of returned subscriptions (must be less than 10000, default is 1000)  # noqa: E501

        :param max_count: The max_count of this SubscriptionFilterParameters.  # noqa: E501
        :type: int
        """
        if max_count is not None and max_count > 10000:  # noqa: E501
            raise ValueError(
                "Invalid value for `max_count`, must be a value less than or equal to `10000`"
            )  # noqa: E501
        if max_count is not None and max_count < 1:  # noqa: E501
            raise ValueError(
                "Invalid value for `max_count`, must be a value greater than or equal to `1`"
            )  # noqa: E501

        self._max_count = max_count

    @property
    def offset(self):
        """Gets the offset of this SubscriptionFilterParameters.  # noqa: E501

        Offset (must be less than 10000)  # noqa: E501

        :return: The offset of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: int
        """
        return self._offset

    @offset.setter
    def offset(self, offset):
        """Sets the offset of this SubscriptionFilterParameters.

        Offset (must be less than 10000)  # noqa: E501

        :param offset: The offset of this SubscriptionFilterParameters.  # noqa: E501
        :type: int
        """
        if offset is not None and offset > 10000:  # noqa: E501
            raise ValueError(
                "Invalid value for `offset`, must be a value less than or equal to `10000`"
            )  # noqa: E501
        if offset is not None and offset < 0:  # noqa: E501
            raise ValueError(
                "Invalid value for `offset`, must be a value greater than or equal to `0`"
            )  # noqa: E501

        self._offset = offset

    @property
    def sort_order(self):
        """Gets the sort_order of this SubscriptionFilterParameters.  # noqa: E501

        Sort based on order of results. 'asc' for ascending order or 'desc' for descending order (default value)  # noqa: E501

        :return: The sort_order of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: str
        """
        return self._sort_order

    @sort_order.setter
    def sort_order(self, sort_order):
        """Sets the sort_order of this SubscriptionFilterParameters.

        Sort based on order of results. 'asc' for ascending order or 'desc' for descending order (default value)  # noqa: E501

        :param sort_order: The sort_order of this SubscriptionFilterParameters.  # noqa: E501
        :type: str
        """
        if sort_order is not None and not re.search(
            r"asc|desc", sort_order
        ):  # noqa: E501
            raise ValueError(
                r"Invalid value for `sort_order`, must be a follow pattern or equal to `/asc|desc/`"
            )  # noqa: E501

        self._sort_order = sort_order

    @property
    def customer_id(self):
        """Gets the customer_id of this SubscriptionFilterParameters.  # noqa: E501

        Merchant identifier of customer account  # noqa: E501

        :return: The customer_id of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: str
        """
        return self._customer_id

    @customer_id.setter
    def customer_id(self, customer_id):
        """Sets the customer_id of this SubscriptionFilterParameters.

        Merchant identifier of customer account  # noqa: E501

        :param customer_id: The customer_id of this SubscriptionFilterParameters.  # noqa: E501
        :type: str
        """
        if customer_id is not None and len(customer_id) > 32:
            raise ValueError(
                "Invalid value for `customer_id`, length must be less than or equal to `32`"
            )  # noqa: E501
        if customer_id is not None and len(customer_id) < 0:
            raise ValueError(
                "Invalid value for `customer_id`, length must be greater than or equal to `0`"
            )  # noqa: E501

        self._customer_id = customer_id

    @property
    def plan_id(self):
        """Gets the plan_id of this SubscriptionFilterParameters.  # noqa: E501

        Id of plan. Use for searching scheduled subscriptions by plan  # noqa: E501

        :return: The plan_id of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: str
        """
        return self._plan_id

    @plan_id.setter
    def plan_id(self, plan_id):
        """Sets the plan_id of this SubscriptionFilterParameters.

        Id of plan. Use for searching scheduled subscriptions by plan  # noqa: E501

        :param plan_id: The plan_id of this SubscriptionFilterParameters.  # noqa: E501
        :type: str
        """
        if plan_id is not None and len(plan_id) > 32:
            raise ValueError(
                "Invalid value for `plan_id`, length must be less than or equal to `32`"
            )  # noqa: E501
        if plan_id is not None and len(plan_id) < 0:
            raise ValueError(
                "Invalid value for `plan_id`, length must be greater than or equal to `0`"
            )  # noqa: E501

        self._plan_id = plan_id

    @property
    def start_time(self):
        """Gets the start_time of this SubscriptionFilterParameters.  # noqa: E501

        Date and time up to milliseconds (in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format) when requested period starts (inclusive), UTC time, default is 24 hours before 'end_time' (format: yyyy-MM-dd'T'HH:mm:ss'Z')  # noqa: E501

        :return: The start_time of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: datetime
        """
        return self._start_time

    @start_time.setter
    def start_time(self, start_time):
        """Sets the start_time of this SubscriptionFilterParameters.

        Date and time up to milliseconds (in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format) when requested period starts (inclusive), UTC time, default is 24 hours before 'end_time' (format: yyyy-MM-dd'T'HH:mm:ss'Z')  # noqa: E501

        :param start_time: The start_time of this SubscriptionFilterParameters.  # noqa: E501
        :type: datetime
        """

        self._start_time = start_time

    @property
    def end_time(self):
        """Gets the end_time of this SubscriptionFilterParameters.  # noqa: E501

        Date and time up to milliseconds (in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format) when requested period ends (not inclusive), UTC time, must be less than 7 days after 'start_time', default is current time (format: yyyy-MM-dd'T'HH:mm:ss'Z')  # noqa: E501

        :return: The end_time of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: datetime
        """
        return self._end_time

    @end_time.setter
    def end_time(self, end_time):
        """Sets the end_time of this SubscriptionFilterParameters.

        Date and time up to milliseconds (in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format) when requested period ends (not inclusive), UTC time, must be less than 7 days after 'start_time', default is current time (format: yyyy-MM-dd'T'HH:mm:ss'Z')  # noqa: E501

        :param end_time: The end_time of this SubscriptionFilterParameters.  # noqa: E501
        :type: datetime
        """

        self._end_time = end_time

    @property
    def currency(self):
        """Gets the currency of this SubscriptionFilterParameters.  # noqa: E501

        [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code of transactions currency  # noqa: E501

        :return: The currency of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: str
        """
        return self._currency

    @currency.setter
    def currency(self, currency):
        """Sets the currency of this SubscriptionFilterParameters.

        [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code of transactions currency  # noqa: E501

        :param currency: The currency of this SubscriptionFilterParameters.  # noqa: E501
        :type: str
        """

        self._currency = currency

    class Status(object):
        ACTIVE = "ACTIVE"
        INACTIVE = "INACTIVE"
        CANCELLED = "CANCELLED"
        PAST_DUE = "PAST_DUE"
        PENDING = "PENDING"
        COMPLETED = "COMPLETED"
        CARD_EXPIRED = "CARD_EXPIRED"
        ACTIVATION_FAILED = "ACTIVATION_FAILED"
        UNPAID = "UNPAID"
        WAITING = "WAITING"

    @property
    def status(self):
        """Gets the status of this SubscriptionFilterParameters.  # noqa: E501

        Status of subscription  # noqa: E501

        :return: The status of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: str
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this SubscriptionFilterParameters.

        Status of subscription  # noqa: E501

        :param status: The status of this SubscriptionFilterParameters.  # noqa: E501
        :type: str
        """
        allowed_values = [
            "ACTIVE",
            "INACTIVE",
            "CANCELLED",
            "PAST_DUE",
            "PENDING",
            "COMPLETED",
            "CARD_EXPIRED",
            "ACTIVATION_FAILED",
            "UNPAID",
            "WAITING",
        ]  # noqa: E501
        if status not in allowed_values:
            raise ValueError(
                "Invalid value for `status` ({0}), must be one of {1}".format(  # noqa: E501
                    status, allowed_values
                )
            )

        self._status = status

    class Type(object):
        ONECLICK = "ONECLICK"
        SCHEDULED = "SCHEDULED"
        INSTALLMENT = "INSTALLMENT"

    @property
    def type(self):
        """Gets the type of this SubscriptionFilterParameters.  # noqa: E501

        Type of subscription. 'ONECLICK' type will be ignored.  # noqa: E501

        :return: The type of this SubscriptionFilterParameters.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this SubscriptionFilterParameters.

        Type of subscription. 'ONECLICK' type will be ignored.  # noqa: E501

        :param type: The type of this SubscriptionFilterParameters.  # noqa: E501
        :type: str
        """
        allowed_values = ["ONECLICK", "SCHEDULED", "INSTALLMENT"]  # noqa: E501
        if type not in allowed_values:
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}".format(  # noqa: E501
                    type, allowed_values
                )
            )

        self._type = type

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(
                    map(lambda x: x.to_dict() if hasattr(x, "to_dict") else x, value)
                )
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(
                    map(
                        lambda item: (item[0], item[1].to_dict())
                        if hasattr(item[1], "to_dict")
                        else item,
                        value.items(),
                    )
                )
            else:
                if value is not None:
                    result[attr] = value
        if issubclass(SubscriptionFilterParameters, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, SubscriptionFilterParameters):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
